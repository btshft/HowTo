# Каррирование и частичное применение

В данной статье мы рассмотрим некоторые техники в Javascript, которые широко распространены в функциональных языках программирования.
А именно, как уже понятно из заголовка статьи, будут рассмотрены понятия **_каррирования_** и **_частичного применения_**. Не беспокойтесь, для понимания
этих вещей вам не нужно иметь знания в функциональном программировании.

## Краткие сведения о функциях
Стоит отметить, что для понимания приведенного в статье материала, необходимо иметь представления о функциях в Javascript, включая
_функции высшего порядка_, _замыкания_, а также знать о применении `call` и `apply`. Если вам не знакомы эти понятия, ознакомьтесь с ними в интернете,
а затем возвращайтесь к данной статье.

Сперва, давайте рассмотрим несколько основополагающих вещей относительно функций.

> _**Арность** (анг. Arity) функции определяет количество аргументов, которые может принимать функция. Соответственно, можно выделить
несколько основных видов арностей функций:_
* Нульарный — функция не принимает аргументов
* Унарный — функция принимает один аргумент
* Бинарный — Функция принимает два аргумента
* n-арный — Функция принимает n аргументов
* Полиарный (мультиарный) — функция принимает любое количество аргументов. В Javascript такие функции называют функциями с 
переменным количеством аргументов (variadic functions)

В Javascript можно узнать количество объявленных аргументов функции обратившись к её свойству `.length`. Данное свойство неизменяемо
и всегда соответствует количеству объявленных аргументов функции. Важно отметить, что количество реальных аргументов, переданных
в функцию при вызове может отличаться от количества объявленных аргументов.

``` javascript
function howMany(a,b,c) {
  console.log(howMany.length);
}

howMany(1,2);      // 3
howMany(1,2,3,4);  // 3
```
Очевидно, что количество аргументов функции зависит от вас. Это свойство позволяет обрабатывать случаи, когда в 
функцию было передано слишком мало, либо слишком много аргументов. 

> **Функции с переменным количеством аргументов** (variadic functions) — это функции, которые принимают неопределенное количество аргументов

Javascript также предоставляет механизм доступа к _реальному_ количеству переданных аргументов функции при помощи переменной
`arguments`, которая доступна внутри области видимости функции. Эта переменная содержит _подобный массиву_ список всех аргументов, переданных
в функцию при вызове. 

Я написал "_подобно массиву_", так как не смотря на то, что `arguments` это список, он содержит только свойство `.length`, 
и не содержит других свойств, которыми обладает реальный объект типа `Array`. Вы можете получить доступ к отдельным
элементам списка аргументов при помощи оператора `[]`, а также можете сделать обход по всему списку, используя свойство
`.length`.

Но мы можем легко конвертировать список аргументов в 'реальный' массив, который позволит взаимодействовать с аргументами
функции более привычным и удобным для нас образом:

```javascript
function showArgs() {
  var args = [].slice.call(arguments);
}
```
Вызов `[].slice.call(arguments)` это сокращение следующего вызова `Array.prototype.slice.call(arguments)`, в данном
случае мы просто используем преимущество сокращенной записи литерала массива.

В **ES6** мы можем получить доступ к аргументам и _"распаковать"_ их ещё более простым способом. А именно — с помощью
оператора spread/gather:

```javascript
function howMany(...args) {
  console.log("args:", args, ", length:", args.length);
}
howMany(1,2,3,4); // args: [1,2,3,4], length: 4 (прим. args - "реальный" массив)
```

Со всем рассмотренным выше, что я уверен, вы знали до этого, мы можем перейти к самой теме статьи!

## Каррирование 
> _**Каррирование** — это процесс превращения функции, принимающей N аргументов, в цепочку из N функций,
принимающих свои аргументы по одному._

Разберем определение на примере. Допустим, у нас есть функция `add()`, которая принимает 3 аргумента и возвращает
их сумму. Выглядит она следующим образом:

```javascript
function add(a,b,c) { return a + b + c; }
```
Мы можем _каррировать_ эту функцию и она примет следующий вид:

```javascript
function curriedAdd(a) {
  return function(b) {
    return fuction(c) {
      return a + b + c;
    }
  }
}
```
Как работает каррирование ? Оно работает с использованием механизма вложенных функций для каждого из
возможных аргументов. При этом образуются замыкания, с помощью которых вложенные функции получают доступ к аргументам
родительских функций.

<тут будет пикча>

Что нам необходимо, так это обобщенный способ преобразования любой функции, принимающей N аргументов в цепочку
из N функций, принимающих аргументы по одному. Это необходимо чтобы не писать для каждой возможной функции её 
каррированное представление.

### Пишем обобщенную функцию каррирования
Давайте для начала представим интерфейс, который мы хотим получить в итоге. Это полезно, так как позволяет на этапе
идеи заложить основные требования к разрабатываемому функционалу. 

```javascript
function foo(a,b,c) { return a + b + c; }
var curriedFoo = curry(foo);

curriedFoo(1,2,3);    // 6
curriedFoo(1)(2,3);   // 6
curriedFoo(1)(2)(3);  // 6
curriedFoo(1,2)(3);   // 6
```
Наш прототип `curry()` возвращает новую функцию, которую можно вызвать с одним или большим количеством аргументов,
которые будут частично применены для получения результата. И так до тех пор, пока мы не передадим последний аргумент
(основываясь на арности оригинальной функции), на этом этапе функция вернет результат выполнения оригинальной функции
с полным набором аргументов.

Из рассмотренного выше материала нам известно, что мы можем получить арность оригинальной функции при помощи свойства
`.length`. Мы можем использовать эти знания для того, чтобы узнать какое количество функций из одного аргумента должно
содержать каррированное представление некоторой функции из N аргументов.

Также нам необходимо сохранить оригинальную функцию, чтобы при получении необходимого количества аргументов, передать их
ей для получения результата. Итак, первая попытка:

```javascript
fuction curry(fn) {
  return fuction curried() {
    var args = [].slice.call(arguments);
    return args.length >= fn.length 
      ? fn.apply(null, args)
      : function() {
          var rest = [].slice.call(arguments);
          return curried.apply(null, args.concat(rest));
      };
  };
}
```
Давайте детально рассмотрим что же тут происходит...
* **Строка 1**: Наша функция `curry` возвращает новую функцию с именем `curried()`
* **Строка 3**: Каждый раз при вызове этой функции мы сохраняем переданные аргументы в массив `args`
* **Строка 4**: Если количество аргументов равно арности оригинальной функции, значит мы получили их все, тогда:
* **Строка 5**: Вызываем оригинальную функцию со всеми аргументами для получения результата
* **Строка 6**: Иначе возвращаем функцию, которая принимет оставшуюся часть аргументов и снова вызовет нашу функцию 'curried', совместив
полученные новые аргументы с теми, что были переданы раньше. 

Давайте попробуем применить разработанную функцию на наш предыдущий пример с функцией `add()`:

``` javascript
var curriedAdd = curry(add);
curriedAdd(1)(2)(3); // 6
curriedAdd(1)(2,3);  // 6
```

Отлично! Именно то, что и задумывалось изначально. Однако, давайте представим что у нас есть объект с методами, которые зависят
от свойств самого объекта. Сможем ли мы применить разработанную функцию для каррирования метода данного объекта? Давайте посмотрим:

```javascript
var border = {
  style: 'border',
  generate: function(length, measure, type, color) {
    return [this.style + ':', length + measure, type, color].join(' ') + ';';
  }
}

border.curriedGenerate = curry(border.generate);
border.curriedGenerate(2)('px')('solid')('#369'); // => "undefined: 2px solid #369;"
```
Кажется, это не то, на что мы рассчитывали.

Использование `curry()` в качестве декоратора метода нарушает контекст оригинального объекта, который ожидается методом `generate`.
Поэтому нам необходимо доработать функцию таким образом, чтобы помимо сохранения аргументов на этапе выполнения цепочки, также 
сохранять оригинальный контекст объекта и передавать его на протяжении всех последующих вызовов функции `curried`.

```javascript
function curry(fn) {
  return function curried() {
    var args = [].slice.call(arguments),
        context = this;
    return args.length >= fn.length
      ? fn.apply(context, args)
      : function() {
          var rest = [].slice.call(arguments);
          return curried.apply(context, args.concat(rest));
      };
  };
}
```
Давайте попробуем снова

```javascript
borded.curriedGenerate(2)('px')('solid')('#369'); // => "border: 2px solid #396;"
```

Великолепно! Теперь наша функция `curry()` обладает информацией о контексте объекта и может быть использована в качестве
декоратора функций.

### Каррирование функций с переменным количеством аргументов
Наше текущее решение работает отлично и правильно, однако только для функций, количество объявленных аргументов которых совпадает
с количеством передаваемых. Это совсем не поможет нам в каррировании функций с переменным количеством аргументов.

Чтобы использовать каррирование на данном типе функций, нам нужен механизм, с помощью которого мы можем сообщить `curry()`, когда
количество аргументов будет достаточным для вызова оригинальной функции.

Возьмем для рассмотрения следующие два примера. Первый из них является функцией с переменным количеством аргументов, а второй - 
функцией с необязательным аргументов:

```javascript
function max(/* var-args */) {
  var args = [].slice.call(arguments);
  return Math.max.apply(Math, args);
}

function range(start, end, step) {
  var stop = Math.max(start, end),
      start = Math.min(start, end),
      set = [];
      
  // step является опциональным параметром
  step = typeof step !== 'undefined' ? step : 1;
  
  for(var i = start; i <= stop; i+= step) {
    set.push(i);
  }
  return set;
}
```
В первом примере, если мы попытаемся вызвать `curry(max)(1)(2)(3)`, вычисление произойдет до передачи аргументов и мы получим
`TypeError`.
Во втором примере наблюдается обратная ситуация, вызов `curry(range)(1)(10)` приведет к тому, что мы получим новую функцию, которая
будет ожидать передачи третьего аргумента `step`.

К сожалению, в Javascript не представляется возможным реализовать `curry` для каррирования функции `max()`. Проблема заключается в
том, что без информации об минимальном количестве аргументов, достаточном для вычисления функции, невозможно определить количество
элементов цепочки из функций с одним аргументом.

Однако, мы можем попробовать обработать случай, когда последние аргументы в оригинальной функции являются опциональными, как в примере с `range`. 
Для этого нам необходимо внести небольшие изменения в `curry`, а именно - добавить опциональный второй аргумент, который бы определял
минимальной количество аргументов оригинальной функции, с которым мы можем её вызвать. 

```javascript
function curry(fn, n) {
  var arity = n || fn.length;
  return function curried() {
    var args = [].slice.call(arguments),
        context = this;
    
    return args.length >= arity 
      ? fn.apply(context, args)
      : function() {
          var rest = [].slice.call(arguments);
          return curried.apply(context, args.concat(rest));
      };
  };
}
```

Теперь мы можем каррировать `range` следующим образом `curry(range, 2)(1)(10)`, а также как: `curry(range, 2)(1)(10, 2)`. 
Однако, увы, мы не сможем применить следующий вид: `curry(range, 2)(1)(10)(2)`, так как здесь мы указываем минимальное количество
аргументов равное двум, так что после передачи аргумента `10` произойдет вычисление оригинальной функции. Правильным вызовом в 
таком случае будет: `curry(range, 3)(1)(10)(2)`.

### Стоит ли мне применять каррирование?
Из предыдущих примером должно быть вполне очевидно, что каррирование в Javascript возможно и полезно в некоторых случаях. Однако,
из-за того что Javascript по своей природе разрешает любой функции иметь переменное количество аргументов, приводит к тому, что
каррирование становится неэффективно для обработки всех возможных случаев.

**Решение**. Если вы пишите в функциональном стиле, с унарными и/или бинарными функциями, а также количество передаваемых аргументов
в функции всегда совпадает с количеством объявленных, каррирование может стать весьма хорошим инструментом в вашем арсенале. В противном
случае стоит убедиться в том, что ограничения, накладываемые на применение `curry()` в языке Javascript, не станут для вас проблемой.

### Каррируем в ES6
Как уже отмечалось выше, в ES6 появился новый оператор `...` (spread/gather), который упрощает взаимодействие с переменным числом
аргументов. Также в ES6 появился стрелочный оператор `=>`(fat-arrow), упрощающий написание анонимных функций и решающих проблему с
захватом лексического контекста 'this'. Так что посыпанный синтаксическим сахаром вариант `curry()` выглядит следующим образом:

```javascript
function curry(fn) {
  return function curried(...args) {
    return args.length >= fn.length
      ? fn.call(this, ...args)
      : (...rest) => curried.call(this, ...args, ...rest);
  };
}
```

### Интересный трюк или полезная техника?
Существует понятие, что применение техник функционального программирования за пределами самого функционального программирования
является избыточным и не приносит ничего, кроме головной боли тем, кто этот код встречает. Однако это не так. И давайте рассмотрим,
как можно применить каррирование для решения повседневных задач. Прежде чем перейти к примерам кода, нужно узнать, а где же в самом
функциональном программировании применяется каррирование, и как оно помогает?

Каррирование, в первую очередь, — это часть философии функционального программирования. Сам дизайн ФП значительно отличается от 
дизайна большей части императивных языков программирования и применяемых в них подходов для написания приложений. Методы
функционального программирования основаны на том, что "функция" является основным модулем, который можно переиспользовать. Отсюда и 
вытекают такие понятия, как каррирование и частичное применение. Именно с использованием данных техник можно превращать функции, 
нацеленные на решение конкретной задачи, в более сложные обобщенные функции.

Так как в Javascript функции можно применять для построения новых функций высшего порядка, применение некоторых техник функционального
программирования вполне обосновано и поможет сделать код чище, понятнее и увеличить количество переиспользуемых функций.

Давайте рассмотрим пример. Пусть у нас есть массив из объектов, который мы получили в ответ на асинхронный вызов:

``` javascript
var records = [
  { id: 1, name: 'Dave',  age: 40, active: true  },
  { id: 2, name: 'Kurt',  age: 43, active: false },
  { id: 3, name: 'Beth',  age: 28, active: true  },
  { id: 4, name: 'Angie', age: 39, active: true  },
  { id: 5, name: 'Adam',  age: 34, active: false }  
];
```
Обычно, когда мы хотим провести различные операции над массивом объектов, например получить список всех id, мы воспользуемся
следующим способом:
``` javascript
var ids = records.map(function(rec) { return rec.id });
```
Использование функции-предиката, как та, что мы передали внутрь `map`, является распространенной практикой, однако такой подход
не позволяет переиспользовать наш предикат для других полей объекта. Поэтому с применением `curry()` мы можем создать более обобщенный
способ получения свойств:

```javascript
var getProp = curry(function(prop, obj) { return obj[prop]; });
var ids = records.map(getProp('id'));
```
Здесь мы использовали `curry()` для того чтобы создать функцию `getProp()`, которая принимает название свойства объекта как
аргумент и возвращает новую функцию, которая в качестве аргумента принимает объект массива и возвращает его соответствующее свойство.
Ключевой особенностью здесь является то, что `getProp` легко переиспользовать для получения других свойств объекта, таких как имена, возраст
и т.д. Так что нам не нужно на каждое отдельное свойство писать свой callback.

Мы можем сделать ещё один шаг вперед. Скажем, мы хотим улучшить `Array.prototype.map`, сделав возможным использовать частичное
применение предиката на неё, до того как передадим массив данных. Как это выглядит:

```javascript
var mapWith = curry(function(fn, list) { return list.map(fn); });
var getNames = mapWith(getProp('name'));
var names = getNames(records);
```

Таким образом можно сказать, что существуют случаи, в которых применение техник функционального программирования, поможет улучшить
ваш код, как с точки зрения чистоты, так и с точки зрения переиспользования отдельных составляющих.

## Частичное применение
//TODO

### Частичное применение в ES6
//TODO

> Данная статья является вольным переводом [оригинальной статьи](http://www.datchley.name/currying-vs-partial-application)
(дата обращения: 26-05-2016). Все права на приведенные фрагменты кода принадлежат автору.
